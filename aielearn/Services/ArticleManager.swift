//
//  ArticleManager.swift
//  aielearn
//
//  Created by AI Assistant
//

import Foundation
import Combine
import SwiftUI

@MainActor
class ArticleManager: ObservableObject {
    @Published var availableArticles: [Article] = []
    @Published var readingSessions: [ArticleReadingSession] = []
    @Published var articleQuizResults: [ArticleQuizResult] = []
    @Published var readingStats: ReadingStats = ReadingStats()
    
    // Error messaging (keep this separate from loading)
    @Published var errorMessage: String?
    
    // Loading state manager
    private let loadingManager = LoadingStateManager.shared
    
    // Auto-flow state for seamless experience
    @Published var shouldAutoStartReading = false
    @Published var autoGeneratedArticle: Article?
    @Published var autoGeneratedQuestions: [QuizQuestion] = []
    
    // Current reading session
    @Published var currentReadingSession: ArticleReadingSession?
    
    private var openAIService: OpenAIService?
    private var cancellables = Set<AnyCancellable>()
    
    init() {
        loadStoredData()
    }
    
    // MARK: - Computed Properties for Backward Compatibility
    var isGenerating: Bool {
        loadingManager.isLoading(.quizGeneration)
    }
    
    // MARK: - Service Configuration
    func setOpenAIService(_ service: OpenAIService?) {
        self.openAIService = service
        print("ðŸ“š ArticleManager: OpenAI service \(service != nil ? "configured" : "cleared")")
    }
    
    var configuredOpenAIService: OpenAIService? {
        return openAIService
    }
    
    // MARK: - Article Generation
    func generateArticle(for userProfile: UserProfile, specificTopic: String? = nil) {
        guard let openAIService = openAIService else {
            setError("OpenAI service not configured. Please check your API key.")
            return
        }
        
        guard !loadingManager.isLoading(.quizGeneration) else {
            print("âš ï¸ Article generation already in progress")
            return
        }
        
        print("ðŸš€ Starting article generation for user profile: \(userProfile.proficiencyLevel)")
        
        errorMessage = nil
        
        let request = ArticleGenerationRequest(
            topic: userProfile.preferredTopic,
            difficulty: userProfile.proficiencyLevel,
            focus: userProfile.learningFocus,
            wordCount: calculateWordCount(for: userProfile.proficiencyLevel),
            specificSubject: specificTopic
        )
        
        Task {
            do {
                let result = try await loadingManager.withLoadingMainActor(.quizGeneration, message: "Creating your personalized article...") {
                    return try await openAIService.generateArticleWithQuestions(request: request)
                }
                
                await MainActor.run {
                    self.handleGenerationSuccess(result: result, userProfile: userProfile)
                }
            } catch {
                await MainActor.run {
                    self.handleGenerationError(error: error)
                }
            }
        }
    }
    
    private func calculateWordCount(for level: ProficiencyLevel) -> Int {
        switch level {
        case .beginner: return 200
        case .intermediate: return 250
        case .advanced: return 300
        }
    }
    
    @MainActor
    private func handleGenerationSuccess(result: ArticleWithQuestions, userProfile: UserProfile) {
        print("âœ… Article generation successful: \(result.article.title)")
        
        // Add to available articles
        availableArticles.insert(result.article, at: 0)
        
        // Set up auto-flow
        autoGeneratedArticle = result.article
        autoGeneratedQuestions = result.questions
        shouldAutoStartReading = true
        
        // Save data
        saveStoredData()
        
        print("ðŸ“š Article ready for reading: \(result.article.wordCount) words, \(result.questions.count) questions")
    }
    
    @MainActor
    private func handleGenerationError(error: Error) {
        print("âŒ Article generation failed: \(error.localizedDescription)")
        setError("Failed to generate article: \(error.localizedDescription)")
    }
    
    private func setError(_ message: String) {
        errorMessage = message
        
        // Clear error after 5 seconds
        DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
            if self.errorMessage == message {
                self.errorMessage = nil
            }
        }
    }
    
    // MARK: - Reading Session Management
    func startReadingSession(for article: Article) -> ArticleReadingSession {
        let session = ArticleReadingSession(articleId: article.id)
        currentReadingSession = session
        return session
    }
    
    func updateReadingProgress(session: ArticleReadingSession, progress: Double) {
        guard let currentSession = currentReadingSession,
              currentSession.id == session.id else { return }
        
        // Update progress (simplified - in real app you'd update the session object)
        // For now, we'll track completion when progress reaches 1.0
        if progress >= 1.0 {
            completeReadingSession(session: session, progress: progress)
        }
    }
    
    func completeReadingSession(session: ArticleReadingSession, progress: Double = 1.0) {
        let completedSession = session.completed(with: progress)
        
        // Add to reading sessions
        readingSessions.append(completedSession)
        
        // Update reading stats
        updateReadingStats(with: completedSession)
        
        // Clear current session
        currentReadingSession = nil
        
        saveStoredData()
        
        print("âœ… Reading session completed for article: \(session.articleId)")
    }
    
    // MARK: - Quiz Results Management
    func recordArticleQuizResult(articleId: UUID, quizResult: QuizResult) {
        let articleQuizResult = ArticleQuizResult(articleId: articleId, quizResult: quizResult)
        articleQuizResults.append(articleQuizResult)
        
        // Update reading stats with comprehension score
        updateReadingStatsWithQuizResult(articleQuizResult)
        
        saveStoredData()
        
        print("ðŸ“Š Article quiz result recorded: \(articleQuizResult.comprehensionScore * 100)% comprehension")
    }
    
    // MARK: - Statistics Management
    private func updateReadingStats(with session: ArticleReadingSession) {
        guard session.isCompleted else { return }
        
        let totalArticles = readingStats.totalArticlesRead + 1
        let totalTime = readingStats.totalReadingTime + (session.readingDuration ?? 0)
        
        // Calculate articles completed this week
        let thisWeekArticles = countArticlesThisWeek()
        
        // Update streak (simplified calculation)
        let newStreak = calculateCurrentStreak()
        
        // Get favorite topics (simplified)
        let favoriteTopics = getFavoriteTopics()
        
        readingStats = ReadingStats(
            totalArticlesRead: totalArticles,
            totalReadingTime: totalTime,
            averageComprehensionScore: readingStats.averageComprehensionScore,
            articlesCompletedThisWeek: thisWeekArticles,
            currentReadingStreak: newStreak,
            favoriteTopics: favoriteTopics
        )
    }
    
    private func updateReadingStatsWithQuizResult(_ result: ArticleQuizResult) {
        // Update average comprehension score
        let totalQuizzes = articleQuizResults.count
        let totalScore = articleQuizResults.reduce(0) { $0 + $1.comprehensionScore }
        let averageScore = totalQuizzes > 0 ? totalScore / Double(totalQuizzes) : 0.0
        
        let favoriteTopics = getFavoriteTopics()
        
        readingStats = ReadingStats(
            totalArticlesRead: readingStats.totalArticlesRead,
            totalReadingTime: readingStats.totalReadingTime,
            averageComprehensionScore: averageScore,
            articlesCompletedThisWeek: readingStats.articlesCompletedThisWeek,
            currentReadingStreak: readingStats.currentReadingStreak,
            favoriteTopics: favoriteTopics
        )
    }
    
    private func countArticlesThisWeek() -> Int {
        let calendar = Calendar.current
        let now = Date()
        let weekAgo = calendar.date(byAdding: .day, value: -7, to: now) ?? now
        
        return readingSessions.filter { session in
            session.isCompleted && session.startTime >= weekAgo
        }.count
    }
    
    private func calculateCurrentStreak() -> Int {
        // Simplified streak calculation
        // In a real app, you'd track daily reading activity
        let recentSessions = readingSessions.filter { session in
            let daysSince = Calendar.current.dateComponents([.day], from: session.startTime, to: Date()).day ?? 0
            return daysSince <= 7 && session.isCompleted
        }
        
        return min(recentSessions.count, 7) // Max 7 day streak for now
    }
    
    private func getFavoriteTopics() -> [LearningTopic] {
        // Get topics from completed articles
        let topicCounts = availableArticles.reduce(into: [LearningTopic: Int]()) { counts, article in
            counts[article.topic, default: 0] += 1
        }
        
        return topicCounts.sorted { $0.value > $1.value }.prefix(3).map { $0.key }
    }
    
    // MARK: - Question Generation for Existing Articles
    func generateQuestionsForArticle(_ article: Article) async {
        guard let openAIService = openAIService else {
            await MainActor.run {
                setError("OpenAI service not configured. Please check your API key.")
            }
            return
        }
        
        await MainActor.run {
            errorMessage = nil
        }
        
        print("ðŸ¤” Generating questions for article: \(article.title)")
        
        do {
            let request = ArticleQuestionGenerationRequest(
                article: article,
                questionCount: 10
            )
            
            let questions = try await loadingManager.withLoadingMainActor(.quizGeneration, message: "Generating quiz questions...") {
                return try await openAIService.generateQuestionsForArticle(request: request)
            }
            
            await MainActor.run {
                self.autoGeneratedQuestions = questions
                print("âœ… Generated \(questions.count) questions for article: \(article.title)")
            }
        } catch {
            await MainActor.run {
                self.handleGenerationError(error: error)
            }
        }
    }
    
    // MARK: - Auto-flow Management
    func resetAutoFlowState() {
        shouldAutoStartReading = false
        autoGeneratedArticle = nil
        autoGeneratedQuestions = []
    }
    
    // MARK: - Data Persistence
    private func saveStoredData() {
        // Save articles
        if let articlesData = try? JSONEncoder().encode(availableArticles) {
            UserDefaults.standard.set(articlesData, forKey: "SavedArticles")
        }
        
        // Save reading sessions
        if let sessionsData = try? JSONEncoder().encode(readingSessions) {
            UserDefaults.standard.set(sessionsData, forKey: "ReadingSessions")
        }
        
        // Save quiz results
        if let resultsData = try? JSONEncoder().encode(articleQuizResults) {
            UserDefaults.standard.set(resultsData, forKey: "ArticleQuizResults")
        }
        
        // Save reading stats
        if let statsData = try? JSONEncoder().encode(readingStats) {
            UserDefaults.standard.set(statsData, forKey: "ReadingStats")
        }
    }
    
    private func loadStoredData() {
        // Load articles
        if let articlesData = UserDefaults.standard.data(forKey: "SavedArticles"),
           let articles = try? JSONDecoder().decode([Article].self, from: articlesData) {
            availableArticles = articles
        }
        
        // Load reading sessions
        if let sessionsData = UserDefaults.standard.data(forKey: "ReadingSessions"),
           let sessions = try? JSONDecoder().decode([ArticleReadingSession].self, from: sessionsData) {
            readingSessions = sessions
        }
        
        // Load quiz results
        if let resultsData = UserDefaults.standard.data(forKey: "ArticleQuizResults"),
           let results = try? JSONDecoder().decode([ArticleQuizResult].self, from: resultsData) {
            articleQuizResults = results
        }
        
        // Load reading stats
        if let statsData = UserDefaults.standard.data(forKey: "ReadingStats"),
           let stats = try? JSONDecoder().decode(ReadingStats.self, from: statsData) {
            readingStats = stats
        }
    }
    
    // MARK: - Helper Methods
    func getArticle(by id: UUID) -> Article? {
        return availableArticles.first { $0.id == id }
    }
    
    func getQuizResults(for articleId: UUID) -> [ArticleQuizResult] {
        return articleQuizResults.filter { $0.articleId == articleId }
    }
    
    func hasCompletedReading(for articleId: UUID) -> Bool {
        return readingSessions.contains { $0.articleId == articleId && $0.isCompleted }
    }
    
    func getReadingSession(for articleId: UUID) -> ArticleReadingSession? {
        return readingSessions.first { $0.articleId == articleId && $0.isCompleted }
    }
    
    // MARK: - Cleanup
    func clearAllData() {
        availableArticles.removeAll()
        readingSessions.removeAll()
        articleQuizResults.removeAll()
        readingStats = ReadingStats()
        
        UserDefaults.standard.removeObject(forKey: "SavedArticles")
        UserDefaults.standard.removeObject(forKey: "ReadingSessions")
        UserDefaults.standard.removeObject(forKey: "ArticleQuizResults")
        UserDefaults.standard.removeObject(forKey: "ReadingStats")
    }
}

// MARK: - ReadingStats Extension
extension ReadingStats {
    init(totalArticlesRead: Int, totalReadingTime: TimeInterval, averageComprehensionScore: Double, articlesCompletedThisWeek: Int, currentReadingStreak: Int, favoriteTopics: [LearningTopic]) {
        self.totalArticlesRead = totalArticlesRead
        self.totalReadingTime = totalReadingTime
        self.averageComprehensionScore = averageComprehensionScore
        self.articlesCompletedThisWeek = articlesCompletedThisWeek
        self.currentReadingStreak = currentReadingStreak
        self.favoriteTopics = favoriteTopics
    }
} 